<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>智能二维码图片生成器 (最终版 - 高清立体效果)</title>
    <style>
        /* CSS样式与上一版基本相同 */
        body { font-family: sans-serif; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; background-color: #f4f4f4; margin: 20px 0; padding: 0 20px; gap: 24px; flex-wrap: wrap; }
        .main-content { flex: 1; max-width: 800px; min-width: 420px; }
        .history-panel { width: 300px; flex-shrink: 0; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .input-group { margin-bottom: 15px; }
        .input-group textarea { width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
        button { border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #output { margin-top: 20px; text-align: center; }
        canvas { border: 1px solid #ccc; max-width: 100%; height: auto; }
        .actions-group { display: flex; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .input-actions button { font-size: 12px; padding: 6px 10px; background-color: #6c757d; color: white; }
        .input-actions button:hover { background-color: #5a6268; }
        .main-actions-container { justify-content: flex-start; margin-top: 20px; }
        .main-actions-container button { padding: 10px 15px; font-size: 14px; color: white; }
        .main-actions-container .generate-btn { background-color: #007bff; }
        .main-actions-container .generate-btn:hover { background-color: #0056b3; }
        .main-actions-container .copy-btn { background-color: #28a745; }
        .main-actions-container .copy-btn:hover { background-color: #218838; }
        .main-actions-container .download-btn { background-color: #17a2b8; }
        .main-actions-container .download-btn:hover { background-color: #138496; }
        .main-actions-container .share-btn { background-color: #ffc107; color: black; }
        .main-actions-container .share-btn:hover { background-color: #e0a800; }
        #history-list { list-style-type: decimal; padding-left: 20px; margin: 0; max-height: 600px; overflow-y: auto; }
        #history-list li { padding: 8px; cursor: pointer; border-radius: 4px; word-break: break-all; }
        #history-list li:hover { background-color: #f0f0f0; }
        .history-panel h2 { margin-top: 0; }
        .history-panel .clear-history-btn { background-color: #dc3545; color: white; margin-top: 10px; padding: 8px 12px; }
        .history-panel .clear-history-btn:hover { background-color: #c82333;}
    </style>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
</head>
<body>

    <!-- 主内容区域 -->
    <div class="main-content">
        <div class="container">
            <div class="input-group">
                <textarea id="qr-data" rows="3" oninput="parseVmessLink()" placeholder="1. 在此粘贴原始vmess链接..."></textarea>
                <div class="actions-group input-actions">
                    <button onclick="pasteFromClipboard()">一键粘贴</button>
                    <button onclick="clearVmessInput()">一键清除</button>
                </div>
            </div>
            <div class="input-group">
                <textarea id="top-text" rows="3" placeholder="2. 在此编辑图片顶部文字..."></textarea>
            </div>
            <div class="actions-group main-actions-container">
                <button class="generate-btn" onclick="generateImage()">生成图片</button>
                <button class="copy-btn" id="copy-button" onclick="copyImage()" style="display: none;">复制图片</button>
                <button class="download-btn" id="download-button" onclick="downloadImage()" style="display: none;">下载图片</button>
                <button class="share-btn" id="share-button" onclick="shareImage()" style="display: none;">分享图片</button>
            </div>
            <div id="output">
                <canvas id="canvas"></canvas>
            </div>
        </div>
    </div>

    <!-- 历史记录面板 -->
    <div class="history-panel container">
        <h2>历史记录</h2>
        <ol id="history-list"></ol>
        <button class="clear-history-btn" onclick="clearHistory()">清空所有历史记录</button>
    </div>

    <script>
        let parsedVmessData = null;
        const HISTORY_KEY = 'qrGeneratorHistory_v3';

        async function pasteFromClipboard() { try { const text = await navigator.clipboard.readText(); document.getElementById('qr-data').value = text; parseVmessLink(); } catch (err) { alert('粘贴失败！请确保已授予浏览器读取剪贴板的权限。'); } }
        function clearVmessInput() { document.getElementById('qr-data').value = ''; document.getElementById('top-text').value = ''; parsedVmessData = null; }
        function copyImage() { const canvas = document.getElementById('canvas'); canvas.toBlob(function(blob) { try { navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]); alert('图片已成功复制到剪贴板！'); } catch (error) { alert('复制失败！您的浏览器可能不支持此功能或未授予权限。'); } }, 'image/png'); }
        function downloadImage() { const canvas = document.getElementById('canvas'); const link = document.createElement('a'); link.download = '二维码.png'; link.href = canvas.toDataURL('image/png'); link.click(); }
        async function shareImage() { const canvas = document.getElementById('canvas'); const topText = document.getElementById('top-text').value.replace(/\n/g, ' ') || '二维码图片'; canvas.toBlob(async (blob) => { const file = new File([blob], '二维码.png', { type: 'image/png' }); const shareData = { title: '分享二维码', text: topText, files: [file] }; try { await navigator.share(shareData); } catch (error) { if (error.name !== 'AbortError') { alert('分享失败，发生未知错误。'); } } }, 'image/png'); }
        
        function saveToHistory(entry) { let history = JSON.parse(localStorage.getItem(HISTORY_KEY)) || []; if (history.length > 0 && JSON.stringify(history[0].data) === JSON.stringify(entry.data)) { return; } history.unshift(entry); if (history.length > 50) history = history.slice(0, 50); localStorage.setItem(HISTORY_KEY, JSON.stringify(history)); renderHistory(); }
        function renderHistory() { const history = JSON.parse(localStorage.getItem(HISTORY_KEY)) || []; const listElement = document.getElementById('history-list'); listElement.innerHTML = ''; history.forEach((entry, index) => { const li = document.createElement('li'); const title = entry.data.topText.replace(/\n/g, ' ') || entry.data.vmess || '[无标题]'; li.textContent = title; li.title = `点击恢复: ${title}`; li.onclick = () => loadFromHistory(index); listElement.appendChild(li); }); }
        function loadFromHistory(index) { const history = JSON.parse(localStorage.getItem(HISTORY_KEY)) || []; if (history[index]) { const entry = history[index]; document.getElementById('qr-data').value = entry.data.vmess; document.getElementById('top-text').value = entry.data.topText; parseVmessLink(); generateImage(entry.settings); } }
        function clearHistory() { if (confirm('确定要清空所有历史记录吗？此操作无法撤销。')) { localStorage.removeItem(HISTORY_KEY); renderHistory(); } }
        
        function parseVmessLink() {
            const qrDataInput = document.getElementById('qr-data');
            const topTextInput = document.getElementById('top-text');
            const link = qrDataInput.value;
            if (link.trim().startsWith('vmess://')) {
                try {
                    const base64String = link.substring(8);
                    const decodedString = atob(base64String);
                    parsedVmessData = JSON.parse(decodedString);
                    if (parsedVmessData.hasOwnProperty('ps')) {
                        // 【功能修改点】: 调整为最新的文本格式
                        const now = new Date();
                        const month = now.getMonth() + 1;
                        const day = now.getDate();
                        const dateString = `${month}月${day}日`;
                        // 格式化为: "-日期\n 备注"
                        topTextInput.value = `-${dateString}\n ${parsedVmessData.ps}`;
                    } else {
                        parsedVmessData.ps = "";
                        topTextInput.value = "";
                    }
                } catch (e) {
                    parsedVmessData = null;
                }
            } else {
                parsedVmessData = null;
            }
        }
        
        function generateImage(settingsOverride) {
            // ====================================================================================================
            // ===                                【最终样式与布局控制中心】                                    ===
            // ====================================================================================================
            // 如果是从历史记录加载，则使用 settingsOverride，否则使用下面的默认设置
            const settings = settingsOverride || {
                // --- 1. 高清与尺寸控制 ---
                scaleFactor: 15,                 // 【清晰度】倍率，数值越大图片越清晰，建议2-3。
                canvasWidth: 420,               // 图片的【显示宽度】。
                canvasHeight: 550,              // 图片的【显示高度】。

                // --- 2. 立体与背景控制 ---
                cardPadding: 8,                // 白色卡片离图片边缘的【边距】。
                cardBackgroundColor: '#FDFDFD',   // 中间白色【卡片的颜色】。
                canvasBackgroundColor: '#F0F2F5', // 最外层【背景的颜色】（建议与网页背景色 #f4f4f4 保持一致）。
                shadowOffsetX: 4,                 // 【阴影】的水平偏移，正数向右。
                shadowOffsetY: 4,                 // 【阴影】的垂直偏移，正数向下。
                shadowColor: 'rgba(0,0,0,0.15)',  // 【阴影】的颜色，建议使用带透明度的黑色。
                shadowBlur: 13,                    // 【阴影】的模糊程度，数值越大越柔和。
                
                // --- 3. 文字样式控制 ---
                topTextSize: 32,                // 【顶部文字】的字体大小。
                topTextColor: '#FF2D2D',        // 【顶部文字】的字体颜色。
                dateTimeTextSize: 18,           // 【下方日期】的字体大小。
                dateTimeTextColor: '#ff7575',   // 【下方日期】的字体颜色。
                
                // --- 4. 智能布局控制 (一般无需修改) ---
                contentVerticalOffset: 15,      // 【整体内容】的垂直偏移量 (0为居中, 负数上移, 正数下移)。
                topTextVerticalOffset: 17,      // 【顶部文字】的相对垂直微调。
                dateTimeVerticalOffset: -20     // 【下方日期】的相对垂直微调。
            };
            // ====================================================================================================
            
            const originalLink = document.getElementById('qr-data').value;
            const topTextFromUser = document.getElementById('top-text').value;
            let finalQrData;

            if (parsedVmessData) {
                // 【功能修改点】: 确保包含换行符的完整文本被用于生成链接
                const newPs = topTextFromUser;
                parsedVmessData.ps = newPs;
                const newJsonString = JSON.stringify(parsedVmessData);
                try {
                    // 【功能修改点】: 使用健壮的Base64编码方法以处理特殊字符
                    const newBase64String = btoa(encodeURIComponent(newJsonString).replace(/%([0-9A-F]{2})/g,
                        function toSolidBytes(match, p1) {
                            return String.fromCharCode('0x' + p1);
                        }
                    ));
                    finalQrData = 'vmess://' + newBase64String;
                } catch (e) {
                    alert('生成二维码失败：文本中可能包含无法编码的特殊字符。');
                    return;
                }
            } else {
                finalQrData = originalLink || topTextFromUser;
            }

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = settings.canvasWidth * settings.scaleFactor;
            canvas.height = settings.canvasHeight * settings.scaleFactor;
            canvas.style.width = settings.canvasWidth + 'px';
            canvas.style.height = settings.canvasHeight + 'px';

            ctx.scale(settings.scaleFactor, settings.scaleFactor);

            ctx.fillStyle = settings.canvasBackgroundColor;
            ctx.fillRect(0, 0, settings.canvasWidth, settings.canvasHeight);

            const cardX = settings.cardPadding;
            const cardY = settings.cardPadding;
            const cardWidth = settings.canvasWidth - settings.cardPadding * 2;
            const cardHeight = settings.canvasHeight - settings.cardPadding * 2;
            const actualQrSize = cardWidth - 20;

            ctx.shadowColor = settings.shadowColor;
            ctx.shadowBlur = settings.shadowBlur;
            ctx.shadowOffsetX = settings.shadowOffsetX;
            ctx.shadowOffsetY = settings.shadowOffsetY;
            
            ctx.fillStyle = settings.cardBackgroundColor;
            ctx.fillRect(cardX, cardY, cardWidth, cardHeight);

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            const topLines = topTextFromUser.split('\n');
            const topTextLineHeight = parseInt(settings.topTextSize, 10) * 1.2;
            const topTextBlockHeight = (topTextFromUser ? topLines.length : 0) * topTextLineHeight;
            const dateTimeLineHeight = parseInt(settings.dateTimeTextSize, 10) * 1.2;
            const dateTimeBlockHeight = dateTimeLineHeight;
            const spacingBetweenElements = 20;

            let totalContentHeight = actualQrSize;
            if (topTextFromUser) { totalContentHeight += spacingBetweenElements + topTextBlockHeight; }
            totalContentHeight += spacingBetweenElements + dateTimeBlockHeight;
            let contentGroupStartY = cardY + (cardHeight - totalContentHeight) / 2 + settings.contentVerticalOffset;

            if (topTextFromUser) {
                let currentY = contentGroupStartY + settings.topTextVerticalOffset;
                ctx.fillStyle = settings.topTextColor; ctx.font = `bold ${settings.topTextSize}px 思源黑体, sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const textStartX = cardX + cardWidth / 2;
                topLines.forEach((line, index) => {
                    const yPos = currentY + (topTextLineHeight / 2) + (index * topTextLineHeight);
                    ctx.fillText(line.trim(), textStartX, yPos);
                });
            }
            
            const qrStartY = contentGroupStartY + (topTextFromUser ? topTextBlockHeight + spacingBetweenElements : 0);
            try {
                const qr = qrcode(0, 'M'); qr.addData(finalQrData); qr.make();
                const qrCanvas = document.createElement('canvas');
                qrCanvas.width = qrCanvas.height = actualQrSize;
                const qrCtx = qrCanvas.getContext('2d');
                qrCtx.fillStyle = '#ffffff'; qrCtx.fillRect(0, 0, actualQrSize, actualQrSize);
                const moduleCount = qr.getModuleCount(); const marginModules = 3; const totalModules = moduleCount + marginModules * 2; const moduleSize = actualQrSize / totalModules;
                for (let row = 0; row < moduleCount; row++) {
                    for (let col = 0; col < moduleCount; col++) {
                        if (qr.isDark(row, col)) {
                            qrCtx.fillStyle = '#000000';
                            const x = (col + marginModules) * moduleSize; const y = (row + marginModules) * moduleSize;
                            qrCtx.fillRect(Math.round(x), Math.round(y), Math.ceil(moduleSize + 0.5), Math.ceil(moduleSize + 0.5));
                        }
                    }
                }

                ctx.drawImage(qrCanvas, cardX + (cardWidth - actualQrSize) / 2, qrStartY, actualQrSize, actualQrSize);
                
                document.getElementById('copy-button').style.display = 'inline-block';
                document.getElementById('download-button').style.display = 'inline-block';
                initializeShareButton(); 
                
                if (!settingsOverride) {
                    const historyEntry = { data: { vmess: originalLink, topText: topTextFromUser }, settings: settings };
                    saveToHistory(historyEntry);
                }

            } catch (e) { alert("生成失败！\n\n原因：您输入的文字太长，导致最终链接超出了二维码的最大容量。\n\n解决方法：请尝试缩短【图片顶部文字】的内容。"); }
            
            const now = new Date(); const pad = (num) => num.toString().padStart(2, '0');
            const dateTimeString = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日 ${pad(now.getHours())}点${pad(now.getMinutes())}分${pad(now.getSeconds())}秒`;
            ctx.font = `bold ${settings.dateTimeTextSize}px 思源黑体, sans-serif`; 
            ctx.fillStyle = settings.dateTimeTextColor; 
            const dateTimeYPos = qrStartY + actualQrSize + spacingBetweenElements + (dateTimeBlockHeight / 2) + settings.dateTimeVerticalOffset;
            ctx.fillText(dateTimeString, cardX + cardWidth / 2, dateTimeYPos);
        }

        function initializeShareButton() { const shareButton = document.getElementById('share-button'); if (navigator.share && navigator.canShare) { const dummyFile = new File(["dummy"], "dummy.png", {type: "image/png"}); if (navigator.canShare({ files: [dummyFile] })) { shareButton.style.display = 'inline-block'; } else { shareButton.style.display = 'none'; } } else { shareButton.style.display = 'none'; } }
        
        window.onload = function() {
            renderHistory();
            initializeShareButton();
        };

    </script>
</body>

</html>
